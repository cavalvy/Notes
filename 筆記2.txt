vagrant reload --provision 

--save 会把依赖包名称添加到 package.json 文件 dependencies 键下。--save-dev 则添加到 package.json 文件 devDependencies 键下。
devDependencies是开发时的依赖，dependencies是发布后还需要依赖的模块（用--save）


vue：

	axios用來獲取json數據的包,是一个基于 Promise 的 HTTP 库，可以在浏览器和 node.js 中使用；
	
	
	要在一个页面中使用另外的指令（非全局注册的指令，我们稍后介绍注册全局指令），我们需要先引入它。引入指令后，我们还需在 directives 中进行局部注册。

	"~bootstrap-sass/assets/fonts/bootstrap/" 中的波浪号（~）会将后面的内容当模块路径对待，默认指向 node_modules 目录。

	// src 的值是用反引号（`）标识的模板字符串，我们只需将变量放在 ${} 的大括号之中
        src: `${this.uploadsUrl}sites/ByvFbNlQYVwhvTyBgLdqitchoacDNznN.jpg`,

	scoped：添加此属性，则样式只在当前组件起作用；

	<router-view> 是一个功能组件，它会渲染路径匹配到的视图组件
	<router-link> 组件支持用户在具有路由功能的应用中导航，通过 <router-link> 上的 to="xxx" 属性可以指定目标地址，xxx这里是一个字符串对应路由配置中的 path。第一个参数是字符串或者一个描述地址对象
	当 <router-link> 被点击后，to 的值就会传到 router.push()
	
	在组件上使用 v-for 指令进行渲染的时候，需要添加 key。它可以方便 Vue 跟踪每个节点的身份，从而重用和重新排序现有元素。每一项的 key 应该是惟一的.
	

	Router
		mode：路由模式，默认值 'hash' 使用井号（ # ）作路由，值 'history' 可利用 History API 来完成页面跳转且无须重新加载.
		linkExactActiveClass 的值是一个类名，用来添加到与当前路由对应的 <router-link> 上，以显示当前精确激活的 <router-link>，其默认值是 'router-link-exact-active'.
	
	
	ES6 
		允许我们使用箭头函数（=>），因此下面写法是等价的：
			events.forEach((event) => {
				el.addEventListener(event, handler, false)
			})
			// 等价于
			events.forEach(function (event) {
				el.addEventListener(event, handler, false)
			})
			var f = a = > a

			//等同于
			var f = function(a){
				return a;  
			}
			//无形参
			var f = () => 5;
			// 等同于
			var f = function () { return 5 };
			
		[...Array(num)] 中的 ... 是扩展运算符\对象展开运算符，我们可以用它展开一个数组或对象。将此对象混入到外部对象屬性中
		Object.assign是ES6新添加的接口,可以接收多个参数，第一个参数是目标对象，后面的都是源对象，assign方法将多个原对象的属性和方法都合并到了目标对象上面，如果在这个过程中出现同名的属性（方法），后合并的属性（方法）会覆盖之前的同名属性（方法）。如下：
		// 合并新旧个人信息，等价于 user = Object.assign({}, stateUser, user)
		user = { ...stateUser, ...user }
	
	nextTick将回调延迟到下次 DOM 更新循环之后执行，nextTick 有一个全局方法 Vue.nextTick，在实例上使用 this.$nextTick，不要忘记 $
	
	注册全局组件需要使用 Vue.component，第一个参数 'xxx' 是组件名称，第二个参数 xxx 是一个对象或者函数
	注册全局指令需要使用 Vue.directive，第一个参数 'xxx' 是指令名称，第二个参数 xxx 是一个对象或者函数
	注册全局过滤器需要使用 Vue.filter，第一个参数 'xxx' 是指令名称，第二个参数 xxx 是一个对象或者函数
	全局方法Vue.xxx = xxx对象或者函数Vue.xxx进行访问
	实例方法Vue.prototype.$xxx，通过this.$xxx 进行访问
	
	Vuex 是一个专为 Vue.js 应用开发的 状态管理模式 , 它可以集中管理应用所有组件的状态
	
	计算属性（computed）用来处理相对复杂的逻辑，并返回一个新的属性，它会根据其依赖的变化而变化
	
	当一个组件需要获取多个状态时候，将这些状态都一一声明就显得重复和冗余了。为了解决这个问题，我们可以使用 mapState 辅助函数帮我们生成對應属性，这样我们就能直接在模板里使用了。
	// 引入 mapState 辅助函数 import { mapState } from 'vuex'
	
	Vuex.Store
		state：共享的状态，我们不能直接更改状态，但是可以像 store.state.user 这样访问一个状态；
		mutations：更改状态的方法，我们可以在这里更改状态，调用方法是像 store.commit('UPDATE_USER', user) 这样提交一个事件类型，这里不能包含异步操作；
		actions：类似于 mutations，但我们不在这里直接更改状态，而是提交前面的 mutation，调用方法是 store.dispatch('xxx') 这样分发一个事件，这里可以包含异步操作；
		Getters：当需要从仓库的 state 中派生出一些状态的时候，我们就可以定义 Getter，你可以认为它是仓库的计算属性。Getter 的第一个参数是 state，通过它可以访问仓库的状态，它的第二个参数是 getters，通过它可以访问仓库的派生状态.
			mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性
		Module:Vuex 允许我们将 store 分割成模块
		
	Vue.extend 用来创建一个新『子类』，其参数是一个包含组件选项的对象。
	使用 new 关键字可以创建一个新的 Message 实例，因为没有指定 el 挂载目标，当前实例处于『未挂载』状态。如：const vm = new Message()
	使用 vm.$mount() 手动地挂载一个未挂载的实例，并返回当前实例，此时我们能从实例获取 $el。如：vm.$mount().$el
		$el和$mout两者在使用效果上没有任何区别，都是为了将实例化后的vue挂载到指定的dom元素中。
		如果在实例化vue的时候指定el，则该vue将会渲染在此el对应的dom中，反之，若没有指定el，则vue实例会处于一种“未挂载”的状态，此时可以通过$mount来手动执行挂载。
	vm.$on 用来监听当前实例上的自定义事件，其第一个参数是事件名称或包含事件名称的数组，其第二个参数是回调函数，该函数会接收触发函数的所有参数。
	
	
	选项 / 数据
		props 是用来传递数据的.數據類型：String，Number，Boolean，Function，Object，Array，Symbol。props 的绑定默认是单向的，需要在父组件上添加 .sync 修饰符，以创建『双向绑定』
		watch 选项提供了一个方法来响应\監聽数据的变化
			通常会在两个路由都渲染相同的组件时监听 '$route' 来得知路由参数的变化,这是因为 Vue 会复用组件实例，以导致组件内的部分钩子不再被调用。如：我们的『编辑文章』和 『创作文章』都使用 Create.vue 组件，当我们从『编辑文章』导航到『创作文章』时（在编辑文章页面点击创作文章按钮），beforeRouteEnter 就不会被调用，所以我们需要监听 '$route'，以响应路由参数的变化。
	
	钩子函数：
	bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置；
		el：指令所绑定的元素，可以用来操作 DOM ；
		binding：一个对象，binding.value 表示指令的绑定值，如 v-title="'我是标题'" 中，绑定值为'我是标题'；
		vnode：Vue 编译生成的虚拟节点；
		oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
		<input v-validator:input.required="{ regex: /^[a-zA-Z]+\w*\s?\w*$/, error: '用户名要求以字母开头的单词字符' }">
			binding.name：指令名，不包括 v- 前缀，这里是 'validator' ；
			binding.value：指令的绑定值，这里是 { regex: /^[a-zA-Z]+\w*\s?\w*$/, error: '用户名要求以字母开头的单词字符' } ；
			binding.arg：传给指令的参数，这里是 'input' ；
			binding.modifiers：一个包含修饰符的对象，这里是 { required: true } ；
		
		
	inserted：被绑定元素插入父节点时调用；
	update：所在组件的 VNode（虚拟节点）更新时调用，但是可能发生在其子 VNode 更新之前；
	componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用；
	unbind：只调用一次，指令与元素解绑时调用，在这里可以移除绑定的事件和其他数据；
	created 在实例创建完成后被立即调用，此时我们已经能访问实例的数据对象和方法了
	mounted 钩子在元素挂载到实例之后调用.(元素指頁面標簽).
	
	
	v-model 指令可以在表单 <input> 及 <textarea> 元素上创建双向数据绑定，v-model会忽略所有表单元素的 value、checked 和 selected 的初始值，而使用 Vue 实例的数据，所以我们需要在 data 里声明对应的初始值.
	使用 .lazy 修饰符，可以使其值在 change 事件后才同步
		在单选选择框中使用 v-model，其值是一个静态字符串，对应选中项的 value，如 'male'；
			<select v-model="sex" class="form-control">
			  <option value="">未选择</option>
			  <option value="male">男</option>
			  <option value="female">女</option>
			</select>
		在多个复选框使用 v-model，其值是一个数组，数组项对应已选项的 value，如 ['运动']；
			<label class="checkbox-inline">
			  <input v-model="hobbies" value="运动" type="checkbox"> 运动
			</label>
			<label class="checkbox-inline">
			  <input v-model="hobbies" value="健身" type="checkbox"> 健身
			</label>

	v-show 是一个条件渲染指令，它只切换元素 CSS 属性的 display

	
	$emit 用于触发当前实例上的事件，其第一个参数是事件名称，后面还可以附加若干参数。如果事件需要雙向綁定對應props事件。$emit第一個參數需要添加update:xxxx
	
	beforeRouteEnter(to, from, next) 是组件内的路由导航守卫，在确认渲染该组件的对应路由前调用。该守卫不能访问 this，但我们通过传一个回调给 next，就可以来访问组件实例。路由未改变，beforeRouteEnter 不会被调用。
	守卫的参数说明如下：
		to：即将要进入的目标路由；
		from：当前导航正要离开的路由，from.name 是路由的名称，对应路由配置中的 name；
		next：一个用来 resolve 当前钩子的方法，需要调用该方法来确认或者中断导航；
			参数 to 和 from 都是 路由对象 （route object），表示当前激活的路由的状态信息，其常用的属性有
				name：路由的名称，如 'Register'；
				path：路由的路径，如 '/auth/register'；
				params：路由参数对象，如 { id: "1" }；
				query：URL 查询参数对象，如 { page: "1" }；
				meta：元信息对象，如 { auth: true }
	beforeEach(to, from, next) 注册一个全局前置守卫，它在导航被触发后调用，我们可以通过跳转或取消的方式守卫导航.
	
	afterEach 注册全局后置钩子，它在导航被确认后调用，因此它不接受 next 函数也不会改变导航本身。
	
	beforeRouteLeave 是组件内的守卫，在离开该组件的对应路由时调用，此时可以访问 this，需要使用 next() 确认导航。
	
	如果当前路由含有默认子路由，则不需要为当前路由指定 name，要导航到当前路由，可以使用默认子路由的 name，如 router.push({ name: 'EditProfile' })
	
	路由路径path中 :xxxx 以冒号开头，代表的是该项参数是动态的，它能匹配任何值
	
	过滤器（filter）常用于格式化文本，以管道符号（ | ）表示。过滤器可以在双括号差值和 v-bind 表达式中使用，比如：
	<abbr :date="date | filterA | moment">{{ date | moment('from', { startOf: 'minute' }) }}</abbr>
	过滤器函数总接收表达式的值 (之前的操作链的结果，如上面 date | filterA 的结果) 作为第一个参数。
	
	参数 ...rest 使用了剩余语法，我们使用它将一个不定数量的参数表示为一个数组。
	
js
	typeof:运算符把类型信息当作字符串返回.
	Object.entries 返回给定对象的键值对数组。
	定義全局變量window.xxx
	shift() 方法用于把数组的第一个元素从其中删除，并返回移除后的第一个元素的值。
	filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。
	splice(index,howmany,item1,.....,itemX) 方法向/从数组中添加/删除项目，然后返回被删除的项目。
	Promise 对象表示一个异步操作的最终状态及其返回的值，因此我们可以在 .then 的回调函数里获取返結果
	some方法用于检测数组中的元素是否满足指定条件.如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测
	
	lodash:这是一个具有一致接口、模块化、高性能等特性的 JavaScript 工具库
	
jq
	contains()方法检测一个元素包含在另一个元素之内：
	
html dom
	target 属性可设置或返回页面中所有链接的默认target屬性值
	isSameNode() 检查两个节点是否是相同节点
	

	
	
	

unlink()删除某文件
在unlink()函数前加上@是用来抑制错误信息输出的。

ad_positions: 廣告位置
ads：圖片
mails：發送郵件

---------------------------------
products：商品
product_specifications：規格（多對一）  商品
product_descriptions： 詳情（一對一）   商品
tags：標籤
product_tags： 商品 && 標籤（多對多）
product_images: 商品圖片 （一對一） 商品|| 規格
product_categories： 商品分類
product_comments： 商品評論（買過先可以評論）
product_advisories： 商品咨詢
brands： 商品品牌
--------------------------

carts： 購物車

-----------------------
countries： 國家（一對多）
zones： 地區 
area-groups: 區域名
zone_to_area_group：區域群組（關聯） 地區<->區域
couriers： 物流公司
courier_shipping_fees： 設置運費價格（區域群組）

--------------------------
pages： 其他頁面配置表。
redemption_centers： 自己提取表
seo_settings: seo設置表
worldhub_configs： 基本信息表

-------------------------
users:
userinfos: 详情（一对一）
user_addresses: 收货地址 （一对多）
user_collect_products： 收藏（一对多）
---------------------------------------------
orders：订单
order_products： 订单商品（一堆多） 商品的规格表
order_pays： 支付信息表
order_shippings： 配送信息
aftership_trackings： 推送wms前
order_close_reasons： 关闭订单

-----------------------------------
live_video_broadcasts： 直播信息
lvb_products： 直播商品信息（多对多） 商品

------------------------------------
roles: 角色表
role_user： 用户角色表（多对多） 用户
permissions： 权限
role_permission：角色权限（多对多）

laravel -----增刪改查
vue--------頁面 

vue-》laravel接口
接口返回數據-》 
vue -》處理頁面




申请ID：
dj0zaiZpPTRGbDZNMXhmWDBKSSZzPWNvbnN1bWVyc2VjcmV0Jng9OGE-
揭秘：
e47b6c0424e55027b198534154115508efd4a1d7
yahoo账号
vergil@vip.163.com
revs.hk


amazon
访问密钥 ID:AKIAJBOJSD4ICKYEN2FQ
私有访问密钥:
LYsOccXAxvpQlOJxuaKNQx4IROC8/snlgBG43G7j
AWS 账户 ID: 9458-9936-0945
规范用户 ID: ff11fd11baf812d92216c0c9b7477e6d6fd9baf080fa90d381463745420d1a9d
用户=ProductAdvertisingAPI-user
Access_Key_ID=AKIAIQUGTZEEAAJILYGA
私有访问密钥=RAr8eO1JnrllDL79fKiWZx2QqBHNMV/wJDQyclpF

AKIAJGWXLMU5TCDTCJZA
nMovGqqIzdXfcO/fI2dUyoCJ1SEk1U2RjNMbUe6n



學習ES6語法









